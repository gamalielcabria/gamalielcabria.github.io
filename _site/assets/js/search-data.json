{"0": {
    "doc": "Intro to Bioinfo",
    "title": "Bioinformatics 101",
    "content": " ",
    "url": "/Intro2Bioinfo/#bioinformatics-101",
    
    "relUrl": "/Intro2Bioinfo/#bioinformatics-101"
  },"1": {
    "doc": "Intro to Bioinfo",
    "title": "üñ•Ô∏è Welcome to Bioinformatics",
    "content": "Hi, you might be wondering why are you learning bioinformatics. It may look intimidating but it is just similar to learning a new language. Better! It is learning a way to learn new language easily. Bioinformatics is a useful tool in today‚Äôs research environment. In academia, industry and medical fields, bioinformatics allowed enhance and efficient understanding of biological processes. Through Bioinformatics, we are able to connect genetic content and their function with the cell and the larger environment as a whole. ",
    "url": "/Intro2Bioinfo/#%EF%B8%8F-welcome-to-bioinformatics",
    
    "relUrl": "/Intro2Bioinfo/#Ô∏è-welcome-to-bioinformatics"
  },"2": {
    "doc": "Intro to Bioinfo",
    "title": "What is Bioinformatics",
    "content": "Bioinformatics is an intersectional field of biology, computer science and statistics. This important field allows the understanding and analysis Big Data collected from genomics, proteomics, metabolomics and other omic fields using computational tools and techniques into a coherent and easily readable and understandable form of knowledge. The application of bioinformatics ranges from drug discovery, evolutionary analysis, ecological dynamics, criminal forensics and even in social studies, such as anthropological and historical analysis of human/animal/plant migration. In this training, we will cover how we perform bioinformatics. It includes the command-line interface and its basic commands, basic useful commands in Unix, BASH, and how to run files in a server. | Lessons | Description | . | Lesson 1 | Unix-environment and the Command-Line | . | Lesson 2 | File Types in Bioinformatics | . | Lesson 3 | Basic Commands and BASH Scripting | . | Lesson 4 | Intro to ARC and SLURM JOB submissions | . Version Control . Version: 1.2a Publish Date: 2025 May 07 . ",
    "url": "/Intro2Bioinfo/#what-is-bioinformatics",
    
    "relUrl": "/Intro2Bioinfo/#what-is-bioinformatics"
  },"3": {
    "doc": "Intro to Bioinfo",
    "title": "Intro to Bioinfo",
    "content": " ",
    "url": "/Intro2Bioinfo/",
    
    "relUrl": "/Intro2Bioinfo/"
  },"4": {
    "doc": "Lesson 1",
    "title": "Lesson 1: The Terminal, the OS, and Bioinfo",
    "content": " ",
    "url": "/Intro2Bioinfo/Lesson1.html#lesson-1-the-terminal-the-os-and-bioinfo",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html#lesson-1-the-terminal-the-os-and-bioinfo"
  },"5": {
    "doc": "Lesson 1",
    "title": "‚ÄúUnix Enviroment‚Äù and Bash Guide",
    "content": "Unix is an OS that originated from the 1960s and directly or indirectly the ancestors of most OS you can see today (Ubuntu, macOS, Android). However, whenever we say ‚Äúunix or unix-like environment‚Äù, it often pertains to the command-line interface that are associated with programming and computer science. Before we start the tutorial, let us brief on the terminologies you‚Äôll often hear. | Terminologies | Definitions | . | OS or Operating Systems | are the main program that manages all other application programs and allows the interaction between the user and the computing hardware (e.g. Windows 11, macOS, Ubuntu) | . | Kernel | are core programs in an operating system that manage and bridge processes/programs and the hardware (e.g. Linux, Windows NT, etc.) | . | Shell | is the interface that you interact with the computer. This is primarily divided as GUI or graphical user interface and the CLI command-line interface | . | GUI | is the interface in which you utilise visual to interact with the computer | . | CLI | is the primary interface in which you interact with the computer through inputting lines of text or command-lines. CLI is often run in terminals such as command prompt in Windows | . | BASH | is a common programming language used in a unix-like environment. Primarily run through CLI | . | HPC or high performance computing | the ability to run programs with large number of cores or memory (RAMs). Primarily done in supercomputers or computer clusters | . ",
    "url": "/Intro2Bioinfo/Lesson1.html#unix-enviroment-and-bash-guide",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html#unix-enviroment-and-bash-guide"
  },"6": {
    "doc": "Lesson 1",
    "title": "Bioinformatics and the Unix‚Äô CLI",
    "content": "Command line interface is primary mode of interaction when running in high performance computing clusters. The additional computing requirement often associated with graphical interface results in most bioinformatics programs and pipeline to be run through command-line interface. In addition to draining computing resources, running GUI-based programs often can be time consuming as you might need to manually click and analyse individual data. Meanwhile, through programming language such as BASH and other softwares in the command-line, you can parallelize your analysis. In this tutorial, we will dive into the anatomy of a command-line interface command/program and learn the basic commands in the terminal and BASH to run your bioinformatic analyses. A Basic Terminal Working with Terminals is oftern associated with old OSes or Linux. Windows OS also has a command-line interface, commonly known as Command Prompt or cmd. Additionally, you can have linux experience also within windows using the Windows Subsystem in Linux or WSL2. To install WSL2: Windows Guide to WSL2 . ",
    "url": "/Intro2Bioinfo/Lesson1.html#bioinformatics-and-the-unix-cli",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html#bioinformatics-and-the-unix-cli"
  },"7": {
    "doc": "Lesson 1",
    "title": "Accessing command-line",
    "content": "For your personal computers, you can access command-line interface through command prompt in Windows OS or the terminal app in MacOS and Linux OSes. | To open command prompt on Windows: . | Search for Run in your search bar | Type cmd and run it | . | To open command prompt on MacOS: . | In Finder, go to Applications &gt; Utilities | Double-click Terminal | . | For Ubuntu and Debian based Linux OS: . | Press your Home or Windows button | And search Terminal | . | . Other than your local desktop, there are ways to access the servers through command-line interface such as the University of Calgary‚Äôs ARC OnDemand service. ",
    "url": "/Intro2Bioinfo/Lesson1.html#accessing-command-line",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html#accessing-command-line"
  },"8": {
    "doc": "Lesson 1",
    "title": "Exercise 1: Accessing Terminal",
    "content": "For this exercise we will be utilising a web-based terminal through the Binder and JupyterLab interface. üìù Note: JupyterLab is an organizing program to run different programming language in uniform and replicable manner. It is a great tool for bioinformatics and data analysis. This guide is made through JupyterLabs and we will talk more about it in the future. Meanwhile, Binder is an online repository for Jupyter notebooks that allow reproducibility with colleages and anyone you want online. To open a terminal in Binder, we will use the JupyterLab made for Happy Bell Bioinformatics (Lee, 2019): . | Open a Firefox (Preferrably) | Click this link to open the Binder link | Let the repository load and you should be able to see an image like this: | Open the Terminal as shown. | . üìù Note: Another option to practice is using the online terminal/linux simulation website Webminal . It requires registration but allows persistent memory in which you can save files generated. ",
    "url": "/Intro2Bioinfo/Lesson1.html#exercise-1-accessing-terminal",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html#exercise-1-accessing-terminal"
  },"9": {
    "doc": "Lesson 1",
    "title": "Working with Terminals",
    "content": " ",
    "url": "/Intro2Bioinfo/Lesson1.html#working-with-terminals",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html#working-with-terminals"
  },"10": {
    "doc": "Lesson 1",
    "title": "Structure of a terminal command",
    "content": "Try running this command: . [/home/jovyan/unix_intro]$ ls /home/jovyan/ --all . The basic structure of command line interface often shows the current working directory [/home/joyvan/unix_intro] and followed by the $. Everything on the right of the $ are user inputed commands. Its structure often follow this structure: . | 1st: &lt;command&gt; [arguments] [options] -or- | 2nd: &lt;program&gt; &lt;command&gt; [arguments] [options] -or- | 3rd: &lt;program&gt; [arguments] [options] | . What do these terms mean: | Terminologies | Definitions | . | Program | The software to run your analysis. | . | Command | The operation within the software that needs to be performed to run your analysis | . | Arguments | Arguments are required field that indicate the user input | . | Options | Parameters that the user adds to pass on to the command to specify the detail of the run. Can be optional or mandatory. | . | ¬† | Options are often key-value pairs with the keys indicates as --keys and the values are the one indicated after a space or = | . | Flags | Options that do not have key-value pair (e.g. ‚Äìall above) | . In the above example, it followed the first structure. The ls is a command with the argument [FILE] showing the location or path of the file/folder of interest and is shown here as /home/jovyan/. The option here is --all which reveals all file and folder hidden. Running the above code should display all files within the FILE path indicated: . $ ls /home/jovyan/ --all total 64 drwxr-xr-x 1 jovyan jovyan 4096 Sep 17 17:28 . drwxr-xr-x 1 root root 4096 Dec 7 2022 .. -rw-r--r-- 1 jovyan jovyan 71 Dec 7 2022 apt.txt -rw-r--r-- 1 jovyan jovyan 220 Apr 4 2018 .bash_logout -rw-r--r-- 1 jovyan jovyan 4018 Dec 7 2022 .bashrc drwxr-xr-x 3 jovyan jovyan 4096 Sep 17 17:28 .cache drwxr-xr-x 8 jovyan jovyan 4096 Dec 7 2022 .git drwxr-xr-x 2 jovyan jovyan 4096 Sep 17 17:28 .ipython drwxr-xr-x 3 jovyan jovyan 4096 Sep 17 17:28 .jupyter -rw-r--r-- 1 jovyan jovyan 4908 Sep 17 17:29 .jupyter-server-log.txt drwxr-xr-x 3 jovyan jovyan 4096 Sep 17 17:28 .local -rw-r--r-- 1 jovyan jovyan 807 Apr 4 2018 .profile -rw-r--r-- 1 jovyan jovyan 395 Dec 7 2022 README.md drwxr-xr-x 5 jovyan jovyan 4096 Dec 7 2022 unix_intro . To learn more about the options of a program you can run man &lt;program&gt; to show its manual or &lt;program/command&gt; --help or &lt;program/command&gt; -h to show its help page. Try Running this code: ls --help to see the other arguments of the program. üìù Note: Not all programs or commands have a manual or help page. ",
    "url": "/Intro2Bioinfo/Lesson1.html#structure-of-a-terminal-command",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html#structure-of-a-terminal-command"
  },"11": {
    "doc": "Lesson 1",
    "title": "Running Commands",
    "content": "Try running this command: . head -n 5 example.txt . The command structure often has flexibility (not always) and you can run the options before the arguments or vice versa as shown above. The options -n 5 was run here in front of the arguments example.txt. The argument states the [File] that needs to be open. The abovesaid command works differently when you run it without the option -n 5. Try Running this code: head example.txt . Without the -n 5 option, the head command displays the first 10 lines of the text by default. Giving the -n 5 option forcefully change the output to the first five lines. Changing the option yields different number of lines you will display. Other command that display text files are tail, more, less, and others. The command tail is the opposite of head and displays the lines from the bottom of the text. The more command displays all the lines in the text file after the comman-line while less displays the text files on a separate screen. Try running these commmands . tail, more, less . ",
    "url": "/Intro2Bioinfo/Lesson1.html#running-commands",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html#running-commands"
  },"12": {
    "doc": "Lesson 1",
    "title": "Filepaths",
    "content": "When running the commands before, we only specify example.txt. This is because the example.txt is already located in our current working directory(CWD). To check our CWD, we can just look to the left of $ or subsequently try running the command: . pwd . The pwd command should display your current location: /home/jovyan/unix_intro. The filepath describes the address or location from the root/ and all the folders below it: jovyan and unix_intro. The subsequent forward slash/ after home are separator to determine the hierarchy of folders within the path. The hierarchy can be visualised as this: . / &lt;-root directory |___bin/ |___dev/ |___home/ |___jovyan/ &lt;\"~\" or the username's 'home' folder |___unix_intro &lt;-current working directory |___data/ |___example.txt |___experiment/ |___six_commands/ . The root / contains the folder bin, dev and home among others while home contains the folder jovyan which has the files. To display again all the files and folder within that location, you can run ls. There should appear the file example.txt along with all other file. ‚úÖ Notice: Running only ls shows you just the name of the file. However, try running ls -l and it should show you all the specifications of the file. This includes the accessibility of the file as indicated by drwx. The user who made the file (jovyan). The usergroup that has access to the file (jovyan). The filesize in bytes (4096/1592) and the files and folders. The folders here are displayed in blue bold fonts while individual files are in white/black font. ‚ö†Ô∏è Warning: Not all terminals has color distinction between files and folders. Better to check ‚Äòfileszie‚Äô as all folders has attribute of 4096 . There are two types of filepath: absolute path and relative path. The absolute path is the location of the file from the root of the drive (e.g. /home/jovyan/unix_intro/example.txt) while relative path is the location of the file depending on your CWD (e.g. example.txt or ./example.txt). üìù Note: In ./example.txt the dot before the forward slash‚Äô/‚Äô indicates that it is the current directory /home/jovyan/unix_intro/. Meanwhile, ../ indicates of the path above the current workind directory. In this case, ../ indicates the folder /home/jovyan/. Therefore, we can have the same result while running the head command with the following examples: . head example.txt . head ./example.txt . `head /home/jovyan/unix_intro/example.txt . Programs and commands can often interchangeably use absolute or relative path but several scripts/programs are created to follow only absolute or relative path. Please check the programs documentation thoroughly to prevent unwanted problems. Moving paths . Unlike in GUI which you can use double-click or back button to move between folders and up and down a path, CLI needs to run a command when changing filepath or location. The primary command use to move paths is the cd or Change Directory command. The cd command is often follow by either absolute or relative path to change locations. Try running this command: . cd ../../ . This command should have move you two folders up your previous location. When you run pwd, you will see that you are in the /home folder. Now try to return to the previous working directory by running an absolute path as argument: cd /home/jovyan/unix_intro. Additionally, from this CWD, if we want to go into the subfolders/subdirectories such as experiment/, we can just run cd experiment. Subsequently, we can return to our previous workind directory by running cd -. Moving and copying files and folders . We also move files and folders using commands in CLI. To move files and folders we used the command mv. The format of this command is mv &lt;original filepath&gt; &lt;destination filepath&gt;. The filepaths can be absolute or relative. Let us try moving example.txt to inside of data/ folder: . Try running this command: . mv ./example.txt ./data/ . Run: ls ./ . And afterwards: ls ./data/ . As you can see, the example.txt did not appear now in ./ but is located in ./data/. We can use similar command when moving folders. Now, let us move back the file example.txt to its original location using mv ./data/example.txt .. The mv command can be used also to rename files and folder. You can try renaming example.txt to any other name. An example: mv example.txt example_edited.txt2. Run a ls afterward. ‚ö†Ô∏è Warning: Renaming files to a filename that is already existing in the destination path would lead to overwriting of the file in the destination path with the file from the orginal filepath. This is a irreversible process that would lead to the loss of the destination filepath‚Äôs original content. Alternatively, you can copy file instead of moving it. When copying files and folder, run the command cp &lt;original filepath&gt; &lt;destination filepath&gt;. These command duplicates your file, so if the file has large sizes ~5-100GB, it might take a while to finish. ‚ö†Ô∏è Warning: Copying files observed the same pitfalls are the moving command. This command can overwrite the files in the destination path too. Be very careful!!! . Making text files . Files can be created through several ways. Programs can create output files based on their output parameters. You can also create your own text files by writing in a text editor. Akin to notepad in windows, you can write text files using several programs such as vim and nano. When creating new text files in this programs, just run the commands: . nano &lt;path to folder destination&gt;/&lt;filename&gt; . vim &lt;path to folder destination&gt;/&lt;filename&gt; . An example: . nano ./data/newtextfile.txtextensioniwant . The previous example would create the text file newtextfile.txtextensioniwant inside the folder data/. If you notice, the file extension (anything beyond .) is not written as the usual .txt file extension. In most cases in a terminal, you can even drop the extension and it will still be treated as a text file. Extensions are just helpful guides for user to know what type of file or program run those file. More on this will be discuss in future lessons. üìù Note: Windows text editors often have different way of representing tabs or newlines than in MacOS and Linux OSes and can affect your program or analyses. However, they can still be open and edited in a Linux or MacOS terminal/text editor. üìù Note: Additionally, Microsoft Word files and other word processor are not recognize as text files as they are save in more elaborate file type. The two text editors are what are often installed by default in different Linux OSes. Focus on learning just one as both can be overwhelming. To learn more on how to use this text editors, click on this links: nano and vim . Vim Text Editor nano Text Editor Lastly, you can create an empty text file using the command touch &lt;filename&gt;. Making folders . For folders, creating a new one requires the command mkdir &lt;filepath&gt;. You cannot create a new folder that already exists. The command will output a warning prompt. You can create multiple folders in a single command with multiple input arguments. When running the command, separating the folder names with spaces as shown: . mkdir test test1 test2 test3 . Removing files and folders . To remove files, use the command rm. For folders with items in it, the command often will prompt you that it cannot remove a folder as it is a directory. You can run rm -r or the recursive option to delete the folder and all subsequent files inside it. ‚ö†Ô∏è Warning: Running this command will permanently delete your files. There is no trash bin to recover your files. So be very paranoid when removing files in important folders. ‚ö†Ô∏è Warning: You can delete other people‚Äôs file in a shared environment even if you do not have a permission to access those files. So be very careful and do not delete other people‚Äôs files. ‚ö†Ô∏è Warning: Again be very attentive in which files you are deleting. It would be better to delete files individually than in a batch, like deleting a whole folder. ",
    "url": "/Intro2Bioinfo/Lesson1.html#filepaths",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html#filepaths"
  },"13": {
    "doc": "Lesson 1",
    "title": "Exercise 2: Creating files and folders",
    "content": "Let us test some skills you should have learn by now. Please do the following instructions: . | Go to your username‚Äôs home folder | Create a folder named Exercise2 | Go to the folder inside unix_intro named six_commands | Get your current working directory | Run ls -all and copy its output by highlighting it with your mouse and using the right-click button | Create a file inside the CWD named exercise2.txt using nano | Paste the text you have copy using Ctrl+Shift+V or the mouse | On the next seven lines, write the colors of the rainbow in any order | Save your file using ^X or colloquially known as Ctrl+X and then Yes | Copy that file to the previously made Exercise2 folder. | Rename the file using mv to exercise2.&lt;whateverextension you prefer&gt; | View the file using either more, less, head or tail commands | . If there are any questions and problems. Do not hesitate to ask. ",
    "url": "/Intro2Bioinfo/Lesson1.html#exercise-2-creating-files-and-folders",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html#exercise-2-creating-files-and-folders"
  },"14": {
    "doc": "Lesson 1",
    "title": "Tips and Summary",
    "content": "Basic Unix-like environment terms . | Terminologies | Definitions | . | path | address of files and folder within the computer | . | CWD/PWD | the current or present working directory is the location of the terminal within the computer hierarchy. This is where you currently are. | . | root | is the top-level directory in a computer partition | . | ¬† | root directory is represented as C:\\ or D:\\ in windows and \\ in Linux or macOS | . | ~ | the user‚Äôs home folder is where the personal files of the user is located. It is often the first location when booting a terminal. | . | ¬† | It can be represented as ~/ but is often located in /home/&lt;username&gt;/ | . | absolute path | the address of file and folder from the specified ‚Äòroot‚Äô or ‚Äòhome‚Äô location | . | relative path | the path of files and folders based on your CWD | . | ./ | In relative path, this indicate the CWD | . | ../ | In relative path, this indicate the folder above the CWD | . | - | When running the cd command, - represents the previous working directory | . Commands in this lecture: . | Commands | Definitions | . | ls | The list command shows the files and folder inside the supplied ARGUMENT | . | head | The head command shows the top lines within the ARGUMENT supplied text file | . | tail | The opposite of head. The tail shows the bottom lines | . | more | Displays a text file within the terminal | . | less | Displays a text file in the terminal on a separate screen instance | . | pwd | a command to show the current or present working directory | . | cd | The change directory command moves the current working directory | . | mv | The move command moves files and folders from the &lt;orginal filepath&gt; to the &lt;destination filepath&gt; | . | cp | The copy command creates a copy of files from the &lt;orginal filepath&gt; to the &lt;destination filepath&gt; | . | mkdir | creates a new directory | . | rm | The remove command deletes a file or folder | . | ¬† | ‚ö†Ô∏è Warning: There is no trash bin in the terminal or linux. Deleted files are deleted permanently | . | nano | A text-editor. Create a file by running nano &lt;filename&gt; | . | vim | Another text-editor similar to previous one | . | ‚Äìhelp | is a flag that aids in identifying all the arguments of most of the command displayed above | . ",
    "url": "/Intro2Bioinfo/Lesson1.html#tips-and-summary",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html#tips-and-summary"
  },"15": {
    "doc": "Lesson 1",
    "title": "Acknowledgement",
    "content": "This tutorial is adapted from Intro to Unix from Happy Belly Bioinformatics by Michael D. Lee or known as AstroBioMike in github. ",
    "url": "/Intro2Bioinfo/Lesson1.html#acknowledgement",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html#acknowledgement"
  },"16": {
    "doc": "Lesson 1",
    "title": "Citation",
    "content": "[1] Lee, (2019). Happy Belly Bioinformatics: an open-source resource dedicated to helping biologists utilize bioinformatics. Journal of Open Source Education, 4(41), 53, https://doi.org/10.21105/jose.00053 . ",
    "url": "/Intro2Bioinfo/Lesson1.html#citation",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html#citation"
  },"17": {
    "doc": "Lesson 1",
    "title": "Lesson 1",
    "content": " ",
    "url": "/Intro2Bioinfo/Lesson1.html",
    
    "relUrl": "/Intro2Bioinfo/Lesson1.html"
  },"18": {
    "doc": "Lesson 2",
    "title": "Lesson 2: Basic Operations in Terminal and BASH",
    "content": " ",
    "url": "/Intro2Bioinfo/Lesson2.html#lesson-2-basic-operations-in-terminal-and-bash",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#lesson-2-basic-operations-in-terminal-and-bash"
  },"19": {
    "doc": "Lesson 2",
    "title": "Auto-completion",
    "content": "Let us return to our home directory cd ~. In this directory, create three folders named test11, test20, and test21 using the mkdir command. Check your folder using ls. Afterwards, try typing head te and tap the tab button once. As you can see, it should auto-complete it to test as it is the next complete string without conflict in our folder. Now, that we have head test in our line, try tapping the tab button twice. It should ring a bell and prompt all possible matches with our initial user input. test11 test20 test21 . ",
    "url": "/Intro2Bioinfo/Lesson2.html#auto-completion",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#auto-completion"
  },"20": {
    "doc": "Lesson 2",
    "title": "Wildcards",
    "content": "Sometimes, we need to work on multiple files folders at the same time but they have different names (e.g. the test1, test 20 and test21). The default command-line shell that we are using allows manipulation of the files through the use of special characters called wildcards *. Try running this command: . ls te* . The above command results in listing all files in the folder that starts with te. This can be used also in a more specific manner. Try running this command: . ls test*1 . Using the wildcard within the string matches anyword that starts with test and ends with 1. It is useful also when runnning commands of files with the same file extension: cp *.fasta ./folder/ . üìù Note: At the command line, the * means any character, any number of times (including 0 times). Let us try removing all the folder we made earlier that start with test simultaneously: . Try running this command: . rm -r test* . ‚ö†Ô∏è Removing files using wildcards should be done carefully as use of wildcards can result in unintended results (e.g. using rm * to delete all files within the folder) . The Question Mark . Another type of wildcard is the use of ? mark. Unlike the * which can match 1 or more strings e.g. (test11111 and test11), the use of test*1 will match both files while use of test?1 will only match test11. Try running this command: . ls test?1 . Which one matches your query? . ",
    "url": "/Intro2Bioinfo/Lesson2.html#wildcards",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#wildcards"
  },"21": {
    "doc": "Lesson 2",
    "title": "Redirectors",
    "content": "The redirection symbols allow the change of destination of outputs (oe even inputs in some instances). Rather than outputs directly showing to your terminal screen, it can be redirected to another command or file. Additionally, redirectors can also be use to push an input to a command. The ‚Äò&gt;‚Äô and ‚Äò&lt;‚Äô . The ‚Äò&gt;‚Äô redirector indicates that the output of any command or process on its left will be transferred to a file indicated on its right. It‚Äôs most basic structure follows this: [command] [any arguments] &gt; [output file] . Try running this command: . ls -all &gt; list.txt . then, open list.txt . Be warned that using an `&gt;` output redirector with an output file that already exists in the destination will lead to the overwriting of that file. To append an existing file (adding output on the end of the file), please use the append `&gt;&gt;` redirector instead. Meanwhile, the ‚Äò&lt;‚Äô redirector indicates that the file in the right of the &lt; will be used as an input to the command to its left: [command][options/arguments] &lt; [input file] . Example: . ```mail -s ‚ÄúNews Today‚Äù gccab@ymail.com &lt; NewsFlash.zip . In this example, we can add the attachment NewsFlash.zip to the command line mail command rather than just sending plain text for email. The `mail` command is command-line command used to send email. It is useful to incorporate in programs or scripts that need immediate notification to the user if they have errors or the run have finished. The pipe ‚Äò|‚Äô . If you want your output to be redirected not into a file but to another process or command, the | or pipe redirector is primarily used. It can be used not only once on a line but can be used to chain several commands to gether. A basic structure would look like this: [command 1] | [command 2] | [command 3] &gt; [output file or STDOUT] . Try running this command: . ls ./data/all | head -n 20 &gt; list.txt . Error redirectors . Several programs often outputed also the errors in STDOUT or terminal screen. You can separate the errors and redirect it to a new distinct file using 2&gt; redirection. It works similar as the normal output redirection but the difference is it will only filter ‚Äòerror‚Äô outputs designated by the program you use. The ‚Äòerror‚Äô redirector 2&gt; can be used alongside a ‚Äòoutput‚Äô redirector but designate it as such 1&gt;. One example would be like this: head nonexistentfile.txt 1&gt; file.out 2&gt; file.err. ",
    "url": "/Intro2Bioinfo/Lesson2.html#redirectors",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#redirectors"
  },"22": {
    "doc": "Lesson 2",
    "title": "Bioinformatic File types and formats",
    "content": " ",
    "url": "/Intro2Bioinfo/Lesson2.html#bioinformatic-file-types-and-formats",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#bioinformatic-file-types-and-formats"
  },"23": {
    "doc": "Lesson 2",
    "title": "Sequence File Formats",
    "content": "Sequencing of DNA and RNA often produce signals of light, chromatogram peaks or electric current as an indication of a nucleotide base. These raw signals are converted into ASCII or computer friendly code using a ‚Äòbasecaller‚Äô or basecalling program. Most of the files that we analysed in bioinformatic analysis are already in this ASCII or alphanumeric format that is readable to both machines and humans. To learn more about basecaller, please look into in this nanopore guide. ",
    "url": "/Intro2Bioinfo/Lesson2.html#sequence-file-formats",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#sequence-file-formats"
  },"24": {
    "doc": "Lesson 2",
    "title": "The  FASTQ format",
    "content": "The most common file format after basecalling is the fastq format or colloquially known as Quality FASTA format. The fastq files contained both nucleotide sequence information, represented with characters as AGCTN, and the quality score of each nucleotide, which are represented by different alphanumeric characters. The quality score is based on Phred Q Score system in which quality is computed as probabilty of error *Pe [2], as computed by this equation: . Qphred=-10 x log10(Pe) . The fastQ file format is composed of four lines: . | Line 1 is the sequence identifier and description and commonly known as header. It often starts with ‚Äò@‚Äô symbol and followed with sequencing information such as sequencer and flow cell lane used. | The second line contains the RAW sequence data and denoted using AGCT characters used in FASTA file. | Line 3 contains the + symbol that separates sequences and quality | The fourthe line meanwhiles contains the quality score of the file in Phred Score Format | . Phred Score . The quality scores ranges from 0-40 with 40 indicating the highest level of quality. Phred quality score can be interpreted as a factor of accuracy as shown in this table: . Quality Scores and Accuracy | Phred Score | Probability of incorrect call | Base Call Accuracy | . | 10 | 1 in 10 | 90% | . | 20 | 1 in 100 | 99% | . | 30 | 1 in 1,000 | 99.9% | . | 40 | 1 in 10,000 | 99.99% | . The ASCII representation of this quality score in fastq files can be seen in this image adapted from NYU: . Phred-64 format is only used by Illumina sequencers while Phred-33 is primarily used by other sequencing file format. ",
    "url": "/Intro2Bioinfo/Lesson2.html#the--fastq-format",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#the--fastq-format"
  },"25": {
    "doc": "Lesson 2",
    "title": "The  FASTA format",
    "content": "FASTA files are the most common file format you will encounter when doing bioinformatic analysis. Unlike FASTQ files with quality score, FASTA files primarily contains only the sequence information using AGCT characters for nucleotides. Aside from this, the N and * are also used as unspecified based and stop character. A nucleotide FASTA File . The FASTA file format is composed of two lines per sequence. The first line starts with &gt; composes the header line. It often has the sequence name and other properties depending on the program used. The second line is composed of the nucleotide sequence file. This can be on capital or small characters. When reading FASTA format of protein sequences, we use single amino acid representations. Here is a sample of a protein FASTA file: . Protein FASTA File The two formats should not be used at the same file as the nucleotide fasta format can be interpreted as a protein fasta file. ",
    "url": "/Intro2Bioinfo/Lesson2.html#the--fasta-format",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#the--fasta-format"
  },"26": {
    "doc": "Lesson 2",
    "title": "Alignment Format",
    "content": "In many downstream analysis, fasta/fastq files are aligned to create a large genome sequence file. Among the most common alignment format used here are the SAM and BAM format. ‚ÄòBAM‚Äô is the binary file format of ‚ÄòSAM‚Äô and often used for its smaller file size. The SAM or Sequence Alignment Map format . %%script false --no-raise-error 1:497:R:-272+13M17D24M 113 1 497 37 37M 15 100338662 0 CGGGTCTGACCTGAGGAGAACTGTGCTCCGCCTTCAG 0;==-==9;&gt;&gt;&gt;&gt;&gt;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; XT:A:U NM:i:0 SM:i:37 AM:i:0 X0:i:1 X1:i:0 XM:i:0 XO:i:0 XG:i:0 MD:Z:37 19:20389:F:275+18M2D19M 99 1 17644 0 37M = 17919 314 TATGACTGCTAATAATACCTACACATGTTAGAACCAT &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&lt;&lt;&gt;&gt;&gt;&lt;&lt;&gt;&gt;4::&gt;&gt;:&lt;9 RG:Z:UM0098:1 XT:A:R NM:i:0 SM:i:0 AM:i:0 X0:i:4 X1:i:0 XM:i:0 XO:i:0 XG:i:0 MD:Z:37 19:20389:F:275+18M2D19M 147 1 17919 0 18M2D19M = 17644 -314 GTAGTACCAACTGTAAGTCCTTATCTTCATACTTTGT ;44999;499&lt;8&lt;8&lt;&lt;&lt;8&lt;&lt;&gt;&lt;&lt;&lt;&lt;&gt;&lt;7&lt;;&lt;&lt;&lt;&gt;&gt;&lt;&lt; XT:A:R NM:i:2 SM:i:0 AM:i:0 X0:i:4 X1:i:0 XM:i:0 XO:i:1 XG:i:2 MD:Z:18^CA19 9:21597+10M2I25M:R:-209 83 1 21678 0 8M2I27M = 21469 -244 CACCACATCACATATACCAAGCCTGGCTGTGTCTTCT &lt;;9&lt;&lt;5&gt;&lt;&lt;&lt;&lt;&gt;&lt;&lt;&lt;&gt;&gt;&lt;&lt;&gt;&lt;&gt;&gt;&lt;9&gt;&gt;&lt;&gt;&gt;&gt;9&gt;&gt;&gt;&lt;&gt; XT:A:R NM:i:2 SM:i:0 AM:i:0 X0:i:5 X1:i:0 XM:i:0 XO:i:1 XG:i:2 MD:Z:35 . As shown above, it is composed of several columns that describes a reads position in the genome. The meaning of each column can be seen here: . We will not discuss this in detail but will tackle in the future. ",
    "url": "/Intro2Bioinfo/Lesson2.html#alignment-format",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#alignment-format"
  },"27": {
    "doc": "Lesson 2",
    "title": "Other File formats",
    "content": "Multiple other file formats are used in Bioinformatics. We will tackle them in detail when we encounter them in our analysis. Here are some of the file formats that are common in a bioinformatic workflow. Bioinformatic files | File Formats | Extension | Definitions | . | FASTQ | .fastq or .fq | contains sequence information and the quality of the sequences | . | FASTA | .fasta or .fa | basic file containing description and sequence information | . | ¬† | .fna | an alternative extension used to denote a nucleotide fasta format | . | ¬† | .faa | an alternative extension used to denote a protein fasta format | . | ¬† | .fa.gz or .fasta.gz or .fq.gz | gunzipped compressed format of FASTA or FASTQ for smaller file size | . | SAM | .sam | a sequence alignment format that details position of each nucleotide. May include quality score and other options depending on the program used | . | BAM | .bam | a compressed or binary form of SAM to lower file size | . | General Feature Format | .gff or .gff2 or .gff3 | is a file format used to describe genes and other general feature of the genome | . | ¬† | ¬† | It is consisting of several columns describing the genes, gene names, position and orientation of the genes | . | Gene Transfer format | .gtf | Similar to GFF files but may containe gene structure data | . | Variant Calling File | .vcf | VCf is the standard format when storing gene variation data such as indels and single nucleotide polymorphisms (SNPs) | . ",
    "url": "/Intro2Bioinfo/Lesson2.html#other-file-formats",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#other-file-formats"
  },"28": {
    "doc": "Lesson 2",
    "title": "Summary",
    "content": " ",
    "url": "/Intro2Bioinfo/Lesson2.html#summary",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#summary"
  },"29": {
    "doc": "Lesson 2",
    "title": "Common operations in Terminal",
    "content": "| Terminologies | Definitions | . | tab | Auto-completion of files or programs available in the terminal | . | * | A catch-all wildcard that matches 0 or more instances | . | ? | A single character wildcard that matches just 1 character instance | . | &gt; | Output redirector that allows both STDOUT and STDERR to be save to a file | . | &lt; | Input redirector that allows files to fill in as STDIN to the command or program | . | &gt;&gt; | Append redirector add STDOUT to the end of the file rather than replacing it | . | 2&gt; | error redirection separates STDERR outputs to a file | . | 1&gt; | STDOUT only redirection to a file | . | \\| | Pipe redirection allows to chain a STDOUT as STDIN to another program | . | STDIN | Standard input are inputs that are often provided to a program or command via terminal | . | STDOUT | Standard output are output of programs and commands and are often shown into the terminal rather than a file | . | STDERR | Standard errors are error outputs of programs and commands that is also often shown in terminal | . ",
    "url": "/Intro2Bioinfo/Lesson2.html#common-operations-in-terminal",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#common-operations-in-terminal"
  },"30": {
    "doc": "Lesson 2",
    "title": "Acknowledgement",
    "content": "This tutorial is adapted from Intro to Unix from Happy Belly Bioinformatics by Michael D. Lee or known as AstroBioMike in github. ",
    "url": "/Intro2Bioinfo/Lesson2.html#acknowledgement",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#acknowledgement"
  },"31": {
    "doc": "Lesson 2",
    "title": "Citation",
    "content": "[1] Lee, M. (2019). Happy Belly Bioinformatics: an open-source resource dedicated to helping biologists utilize bioinformatics. Journal of Open Source Education, 4(41), 53, https://doi.org/10.21105/jose.00053 . [2] Cock, P.J.A, C.J. Fields, N. Goto, M.L. Heuer, &amp; P.M. Rice (2010). The Sanger FASTQ file format for sequences with quality scores, and the Solexa/Illumina FASTQ variants. Nucleic Acids Research, 38(6):1767-1771, https://doi.org/10.1093%2Fnar%2Fgkp1137 . ",
    "url": "/Intro2Bioinfo/Lesson2.html#citation",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html#citation"
  },"32": {
    "doc": "Lesson 2",
    "title": "Lesson 2",
    "content": " ",
    "url": "/Intro2Bioinfo/Lesson2.html",
    
    "relUrl": "/Intro2Bioinfo/Lesson2.html"
  },"33": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": "This is a top-level page. ",
    "url": "/getting-started.html",
    
    "relUrl": "/getting-started.html"
  },"34": {
    "doc": "Welcome",
    "title": "üß¨üñ•Ô∏è Welcome to Microbial Ecology and Bioinformatics Training Suite",
    "content": "Microbial ecology explores the roles, relationships, and diversity of microorganisms in natural environments, from soil and oceans to the human body. These invisible communities drive global biogeochemical cycles, influence climate, and shape ecosystem health. Bioinformatics complements this field by providing computational tools to analyze vast genomic datasets, enabling researchers to uncover microbial functions, interactions, and evolutionary patterns. Together, microbial ecology and bioinformatics reveal the hidden world of microbes and their profound impact on life on Earth. This training suite is made for beginner microbial ecologists as a guide on where to start learning microbial ecology workflows and bioinformatic pipelines. This powered by Just the Docs. ",
    "url": "/#%EF%B8%8F-welcome-to-microbial-ecology-and-bioinformatics-training-suite",
    
    "relUrl": "/#Ô∏è-welcome-to-microbial-ecology-and-bioinformatics-training-suite"
  },"35": {
    "doc": "Welcome",
    "title": "üöÄ Getting Started",
    "content": "To get started, check out the Introduction or browse the topics in the sidebar. # Clone the repository git clone https://github.com/gamaliel cd my-docs-site . ",
    "url": "/#-getting-started",
    
    "relUrl": "/#-getting-started"
  },"36": {
    "doc": "Welcome",
    "title": "Welcome",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  }
}
